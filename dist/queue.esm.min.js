var i=class{events={};on(e,t){typeof this.events[e]!="object"&&(this.events[e]=[]),this.events[e].push(t);let s=this;return function(){s.removeListener(e,t)}}removeListener(e,t){var s;typeof this.events[e]=="object"&&(s=this.events[e].indexOf(t),s>-1&&this.events[e].splice(s,1))}emit(e){if(typeof this.events[e]=="object"){var t,s,n,o=[].slice.call(arguments,1);for(s=this.events[e].slice(),n=s.length,t=0;t<n;t++)try{s[t].apply(this,o)}catch(l){console.error(e,o),console.error(l)}}}once(e,t){return this.on(e,function s(){this.removeListener(e,s),t.apply(this,arguments)})}};function h(r){return new Promise(e=>setTimeout(e,r))}var a=class{#i=0;#e=new Set;#t=0;#s=new i;on(e,t){return this.#s.on(e,t)}add(...e){this.#i++;let t=this.#i;return this.#e.add(t),this.#t++,this.#s.emit("add",e,t),t}remove(e){this.#e.has(e)&&(this.#e.delete(e),this.#t--,this.#s.emit("remove",e))}get size(){return this.#t}async waitForQueueLimitIsFree(e,t=50){for(;this.size>=e;)await h(t)}async waitForCompleteAll(){for(;this.size>0;)await h(50)}};export{a as Queue};
