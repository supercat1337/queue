var r=class{events={};on(t,e){typeof this.events[t]!="object"&&(this.events[t]=[]),this.events[t].push(e);let s=this;return function(){s.removeListener(t,e)}}removeListener(t,e){var s;typeof this.events[t]=="object"&&(s=this.events[t].indexOf(e),s>-1&&this.events[t].splice(s,1))}emit(t){if(typeof this.events[t]=="object"){var e,s,i,o=[].slice.call(arguments,1);for(s=this.events[t].slice(),i=s.length,e=0;e<i;e++)try{s[e].apply(this,o)}catch(l){console.error(t,o),console.error(l)}}}once(t,e){return this.on(t,function s(){this.removeListener(t,s),e.apply(this,arguments)})}};function h(n){return new Promise(t=>setTimeout(t,n))}var a=class{#i=0;#t=new Set;#e=0;#s=new r;on(t,e){return this.#s.on(t,e)}add(...t){this.#i++;let e=this.#i;return this.#t.add(e),this.#e++,this.#s.emit("add",e,t),e}remove(t){this.#t.has(t)&&(this.#t.delete(t),this.#e--,this.#s.emit("remove",t))}async addTaskAndRun(t){let e=this.add(t),s=null;try{s=await t()}catch(i){console.error(i)}finally{this.remove(e)}return s}get size(){return this.#e}async waitForLessThan(t,e=50){for(;this.size>=t;)await h(e)}async waitUntilEmpty(){for(;this.size>0;)await h(50)}};export{a as Queue};
